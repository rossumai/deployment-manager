<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://unpkg.com/@popperjs/core@2/dist/umd/popper.min.js"></script>
<script src="https://unpkg.com/tippy.js@6/dist/tippy-bundle.umd.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"
    integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<style>
    #controls {
        position: fixed;
        left: 0px;
        width: 20%;
        top: 0px;
        height: 10%;
    }

    #chart {
        position: fixed;
        left: 0px;
        right: 0px;
        top: 0px;
        bottom: 0px;
    }

    path.link {
        fill: none;
        stroke: #c5c5c5;
        stroke-width: 1.0px;
    }

    circle {
        /* fill: #ccc; */
        stroke: #fff;
        stroke-width: 1.5px;
    }

    text {
        stroke: #000000;
        font: 11px sans-serif;
        pointer-events: none;
    }

    .ingoing {
        stroke: #237690 !important;
        stroke-width: 4px !important;
        stroke-opacity: 1 !important;
    }

    .outgoing {
        stroke: #FA1209 !important;
        stroke-width: 4px !important;
        stroke-opacity: 1 !important;

    }

    .selected {
        stroke: #000000 !important;
        stroke-width: 1.75px !important;
        stroke-opacity: 1 !important;

    }

    .color-box {
        width: 150px;
        color: white
    }

    .box-red {
        background: #FA1209 !important;
    }

    .box-blue {
        background: #237690 !important;
    }

    .hidden-in-schema {
        opacity: 0.5;
    }
</style>

<body>
    <div id="chart"></div>
    <div id="controls">
        <input type="checkbox" id="cb_hide_orphans" onclick='redraw();'>Hide orphans<br>
        <div>
            <div class="color-box box-red">Dependency of </div>
            <div class="color-box box-blue">Dependends on </div>
        </div>
    </div>
    <script>DUMMY_DATA</script>
    <script>
        function setTooltips() {
            node.attr('data-tippy-content', (d, i) => {
                return `<div>${d.tooltip_content}</div>`;
            });

            tippy(node.nodes(), {
                // content: `<i>hehehe</i>`,
                allowHTML: true
            });
        }

        const NODE_WIDTH = 25;
        const width = 1800;
        const height = 900;

        var chartDiv = document.getElementById("chart");
        var svg = d3.select(chartDiv).append("svg")
            .attr("width", '100%')
            .attr("height", '100%')
            .attr("viewBox", [0, 0, width, height])
            .attr("style", "max-width: 100%; max-height: 100%;");


        field_types = ['captured', 'data_matching', 'data', 'formula', 'manual']
        // Specify the color scale.
        const color = d3.scaleOrdinal(d3.schemeCategory10);

        // The force simulation mutates links and nodes, so create a copy
        // so that re-evaluating this cell produces the same result.
        let links = data.links.map(d => ({ ...d }));
        let nodes = data.nodes.map(d => ({ ...d }));

        function findNode(nodes, id) {
            for (const node of nodes) {
                if (node.id == id) return node
            }
            return { level: 0, delay: 500 }
        }

        var linkedByIndex = {};
        var num_links = {};
        var num_links_incoming = {};
        links.forEach(function (d) {
            linkedByIndex[d.source + "," + d.target] = 1;
            num_links[d.target] = (num_links[d.target] != undefined ? num_links[d.target] + 1 : 1)
            num_links[d.source] = (num_links[d.source] != undefined ? num_links[d.source] + 1 : 1)
            num_links_incoming[d.target] = (num_links_incoming[d.target] != undefined ? num_links_incoming[d.target] + 1 : 1)
            d.distance = findNode(nodes, d.target).level - findNode(nodes, d.source).level
        });

        svg.append("defs")
            .selectAll("marker")
            .data(["marker"])
            .enter().append("marker")
            .attr("id", `arrow`)
            .attr("viewBox", "0 -5 10 10")
            .attr("markerWidth", 4)
            .attr("markerHeight", 4)
            .attr("orient", "auto")
            .append("path")
            .attr("fill", "black")
            .attr("stroke-width", "2px")
            .attr("d", "M0,-5L10,0L0,5");

        const white_background = svg.append("svg:defs")
            .append("filter")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", 1)
            .attr("height", 1)
            .attr("id", "white_background");

        white_background
            .append("feFlood")
            .attr("flood-color", "white");

        white_background
            .append("feComposite")
            .attr("in", "SourceGraphic")

        // Add a line for each link, and a circle for each node.
        const link =
            svg.append("g")
                .attr("fill", "none")
                .attr("stroke-width", 1.5)
                .selectAll("path")
                .data(links)
                .join("line")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.6)

        link
            .attr("marker-end", `url(#arrow)`)

        const node = svg
            .selectAll('circle')
            .data(nodes).enter().append("g")


        const circle = node.append("circle")
            .attr("z", 0)
            .attr("r", NODE_WIDTH)
            .attr("fill", d => color(d.field_type))
            .on("mouseover", highlight(true))
            .on("mouseout", highlight(false))

        node.append("text")
            .attr("class", "fa")
            .style("text-anchor", "middle")
            .style("stroke-width", "2px")
            .style("stroke", "white")
            .text((d) => {
                if (d.field_type == 'formula') {
                    return "\u0046";
                } else if (d.field_type == 'manual') {
                    return '\u004d';
                } else if (d.field_type == 'data_matching') {
                    return '\u0044\u004d';
                } else if (d.field_type == 'data') {
                    return '\u0044\u0041\u0054\u0041';
                } else {
                    return '\u0041\u0049';
                }
            });

        // node.append('title').text((d) => {
        //     if (d.field_type == 'formula') {
        //         return "Formula field";
        //     } else if (d.field_type == 'manual') {
        //         return "Manual field";
        //     } else if (d.field_type == 'data_matching') {
        //         return "Data matching field";
        //     }
        // })

        node.attr('class', (d) => d.is_hidden ? "hidden-in-schema" : "")

        // add the text to nodes
        const title = node.append("text")
            .attr("filter", "url(#white_background)")
            .attr("dy", '2em')
            .style("text-anchor", "middle")
            .style("font-size", "14px")
            .text(function (d) {
                return d.id;
            });


        // Add a drag behavior.
        node.call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

        // Set the position attributes of links and nodes each time the simulation ticks.
        function ticked() {
            function getTargetNodeCircumferencePoint(d) {

                var t_radius = NODE_WIDTH + 10 / 2; // nodeWidth is just a custom attribute I calculate during the creation of the nodes depending on the node width
                var dx = d.target.x - d.source.x;
                var dy = d.target.y - d.source.y;
                var gamma = Math.atan2(dy, dx); // Math.atan2 returns the angle in the correct quadrant as opposed to Math.atan
                var tx = d.target.x - (Math.cos(gamma) * t_radius);
                var ty = d.target.y - (Math.sin(gamma) * t_radius);

                return [tx, ty];
            }


            link
                .attr("x1", d => Math.max(25, Math.min(width - 25, d.source.x)))
                .attr("y1", d => Math.max(25, Math.min(height - 25, d.source.y)))
                .attr("x2", function (d) {
                    return Math.max(25, Math.min(width - 25, getTargetNodeCircumferencePoint(d)[0]));
                })
                .attr("y2", function (d) {
                    return Math.max(25, Math.min(height - 25, getTargetNodeCircumferencePoint(d)[1]));
                });
            // .attr("x1", d => Math.max(25, Math.min(width - 25, d.source.x)))
            // .attr("y1", d => Math.max(25, Math.min(height - 25, d.source.y)))
            // .attr("x2", d => Math.max(25, Math.min(width - 25, d.target.x)))
            // .attr("y2", d => Math.max(25, Math.min(height - 25, d.target.y)));
            // .attr('d', (d) => {
            //     const r = 0// Math.hypot(d.target.x - d.source.x, d.target.y - d.source.y);
            //     return `
            //            M${d.source.x},${d.source.y}
            //            A${r},${r} 0 0,1 ${d.target.x},${d.target.y}
            //              `;
            // })

            node
                .attr("cx", function (d) {
                    return d.x = Math.max(25, Math.min(width - 25, d.x));
                })
                .attr("cy", function (d) {
                    return d.y = Math.max(25, Math.min(height - 25, d.y));
                })
                .attr("transform", function (d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });

        }

        // Create a simulation with several forces.
        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(150))
            .force("charge", d3.forceManyBody())
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collide", d3.forceCollide((d) => 70))
            // .force("x", d3.forceX())
            // .force("y", d3.forceY())
            .on("tick", ticked);

        // const maxlevel = nodes.reduce(function (currentValue, node) {
        //     return Math.max(node.level, currentValue);
        // }, 0);
        // var maxlinks = Object.values(num_links).reduce(function (currentValue, entry) {
        //     return Math.max(entry, currentValue);
        // }, 0);
        // var leveldist = width / (maxlevel + 1);
        // simulation
        //     .force('x', d3.forceX()
        //         .x(function (d) {
        //             return (d.level + 0.025) * leveldist
        //         })
        //         .strength(2.))
        //     .force('y', d3.forceY()
        //         .y(height / 2)
        //         .strength(0.025));

        // Reheat the simulation when drag starts, and fix the subject position.
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }

        // Update the subject (dragged node) position during drag.
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }

        // Restore the target alpha so the simulation cools after dragging ends.
        // Unfix the subject position now that it’s no longer being dragged.
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }

        function highlight(active) {
            return function (e, d) {
                setTooltips()

                link.classed("ingoing", function (link) {
                    return active && link.target === d;
                });
                link.classed("outgoing", function (link) {
                    return active && link.source === d;
                });
                circle.classed("ingoing", function (circle) {
                    return active && linkedByIndex[circle.id + "," + d.id];
                });
                circle.classed("outgoing", function (circle) {
                    return active && linkedByIndex[d.id + "," + circle.id];
                });
                circle.classed("selected", function (circle) {
                    return active && d.id === circle.id;
                });
                circle.classed("ingoing", function (circle) {
                    return active && linkedByIndex[circle.id + "," + d.id];
                });
                circle.classed("outgoing", function (circle) {
                    return active && linkedByIndex[d.id + "," + circle.id];
                });
                circle.classed("selected", function (circle) {
                    return active && d.id === circle.id;
                });
            };
        }

        function redraw() {
            let cb_hide_orphans = document.getElementById("cb_hide_orphans");
            if (cb_hide_orphans.checked) {
                node.style('visibility', (d) => d.is_orphan ? 'hidden' : 'visible')
            } else {
                node.style('visibility', (d) => 'visible')
            }
            simulation.restart();
        }

    </script>
</body>

</html>