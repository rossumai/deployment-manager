{
  "id": 670292,
  "type": "function",
  "name": "Calculating Discounts (S2K PO)",
  "url": "https://us.api.rossum.ai/v1/hooks/670292",
  "description": "",
  "settings": {
    "input": {
      "document payment terms": "terms"
    },
    "output": "document_terms_llm_guess",
    "condition": "{terms}"
  },
  "active": false,
  "events": [
    "annotation_content.updated",
    "annotation_content.initialize"
  ],
  "queues": [
    "https://us.api.rossum.ai/v1/queues/1771791"
  ],
  "run_after": [],
  "metadata": {},
  "config": {
    "schedule": {
      "cron": ""
    },
    "app": null,
    "payload_logging_enabled": false,
    "timeout_s": 30,
    "max_polling_time_s": 300,
    "retry_count": 4,
    "retry_after_polling_failure": true,
    "runtime": "python3.12",
    "code": "import json\nimport re\nimport requests\nimport time\nfrom requests.exceptions import RequestException\nfrom pydantic import BaseModel, ValidationError, confloat\nfrom txscript import TxScript, is_empty\n\n\ndef rossum_hook_request_handler(payload: dict) -> dict:\n    \"\"\"\n    Handles incoming payloads for Rossum hook requests and processes them\n    based on the given configurations, updated datapoints, and other settings.\n\n    :param payload: Dictionary containing request payload data.\n    :return: Dictionary response to be returned to the hook.\n    \"\"\"\n    t = TxScript.from_payload(payload)\n\n    token = payload.get(\"rossum_authorization_token\", \"\")\n    if not token:\n        t.show_error(\"Please set a token owner for the extension.\")\n        return t.hook_response()\n\n    base_url = payload.get(\"base_url\")\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    settings = payload.get(\"settings\", {})\n    action = payload.get(\"action\", \"\")\n    updated_datapoints = payload.get(\"updated_datapoints\", [])\n\n    try:\n        config = Configuration(**settings)\n\n        if not check_condition(t, config.condition):\n            return t.hook_response()\n\n        if action == \"updated\":\n            if not check_for_updates(t, config.input, updated_datapoints):\n                return t.hook_response()\n\n        content = ContentHandler(t, config.input)\n\n        generator = ResponseGenerator(t, content.extracted_data, config.temperature)\n        response = generator.send_request(base_url, headers)\n\n        content.update_datapoints(response, config.output)\n\n    except ValidationError as e:\n        t.show_error(format_validation_errors(e.errors()))\n    except Exception as e:\n        t.show_error(str(e))\n\n    return t.hook_response()\n\n\nclass Configuration(BaseModel):\n    \"\"\"\n    Represents the configuration for processing a hook request.\n\n    Attributes:\n        input (dict[str, str]): Mapping of input fields to process.\n        output  str: output schema_id\n        temperature (float): Temperature for response generation (0.0 to 1.0).\n        condition (str): Condition to evaluate before processing the configuration.\n    \"\"\"\n\n    input: dict[str, str]\n    output: str\n    temperature: confloat(ge=0.0, le=1.0) = 0.0\n    condition: str = \"\"\n\n\nclass ContentHandler:\n    \"\"\"\n    Handles the extraction and updating of content based on the input mapping.\n\n    Attributes:\n        t (TxScript): TxScript object.\n        extracted_data (dict): Extracted data from input mapping.\n    \"\"\"\n\n    def __init__(self, t: TxScript, input_map: dict[str, str]):\n        \"\"\"\n        Initializes the content handler with the transaction script and input mapping.\n\n        :param t: Transaction script object.\n        :param input_map: Mapping of input fields to extract.\n        \"\"\"\n        self.t = t\n        self.extracted_data = self._gather_field_values(input_map)\n\n    def _gather_field_values(self, input_map: dict[str, str]) -> dict:\n        \"\"\"\n        Gathers values for the specified input fields.\n\n        :param input_map: Mapping of input field descriptors to field IDs.\n        :return: Dictionary of gathered field values.\n        \"\"\"\n        results = {}\n        for descriptor, field_id in input_map.items():\n            if not hasattr(self.t.field, field_id):\n                raise ValueError(f\"Field '{field_id}' not found.\")\n            value = getattr(self.t.field, field_id).value\n            results[descriptor] = value\n        return results\n\n    def update_datapoints(self, response_data: dict, target_field: str):\n        \"\"\"\n        Updates datapoints with the response data.\n\n        :param response_data: Dictionary containing response data to update fields.\n        :raises ValueError: If response format is invalid or target fields are not found.\n        \"\"\"\n        try:\n            content = response_data[\"messages\"][1][\"content\"]\n            json_match = re.search(r\"(\\{.*\\}|\\[.*\\])\", content, re.DOTALL)\n            if not json_match:\n                raise KeyError(\"No JSON in LLM's response\")\n            json_data = json_match.group(0)\n\n            if hasattr(self.t.field, target_field):\n                setattr(self.t.field, target_field, json_data)\n            # parsed_response = json.loads(json_data)\n\n            # for item in parsed_response:\n            #     target_field = item[\"field\"]\n            #     new_value = item[\"response\"]\n\n            #     if hasattr(self.t.field, target_field):\n            #         setattr(self.t.field, target_field, new_value)\n            #     else:\n            #         raise ValueError(f\"Target field '{target_field}' not found.\")\n\n        except (KeyError, IndexError) as parse_error:\n            raise ValueError(f\"Invalid response format: {parse_error}\")\n\n\nclass ResponseGenerator:\n    \"\"\"\n    Generates and sends requests to the LLM for processing input data.\n\n    Attributes:\n        t (TxScript): TxScript object.\n        input_data (dict): Data to be processed.\n        output_schema (list): Schema for the desired output.\n        temperature (float): Temperature for response generation.\n        prompt (str): Generated prompt for the LLM.\n    \"\"\"\n\n    def __init__(self, t: TxScript, input_data: dict, temperature: float):\n        \"\"\"\n        Initializes the response generator with input data, output schema, and temperature.\n\n        :param t: Transaction script object.\n        :param input_data: Input data for processing.\n        :param output_schema: Desired output schema.\n        :param temperature: Temperature for the LLM request.\n        \"\"\"\n        self.t = t\n        self.input_data = input_data\n        # self.output_schema = output_schema\n        self.temperature = temperature\n        self.prompt = self._build_prompt()\n\n    def _build_prompt(self) -> str:\n        \"\"\"\n        Builds the prompt for the LLM request.\n\n        :return: Prompt string for the LLM.\n        \"\"\"\n        return (\n            f\"Given the input payment terms text:\\n{json.dumps(self.input_data, indent=2)}\\n\\n\"\n            \"\"\"Given the input payment terms text: <input>{input_text}</input>\n\nParse out the following values from the payment terms text. Return the result as a JSON object with these keys:\n- Days_to_Pay_Net: Number of days to pay the net amount (integer or 0)\n- Days_to_Discount: Number of days to get discount (integer or 0)\n- Day_of_Month_to_Net: Day of month when net payment is due (integer or 0)\n- Day_of_Month_to_Discount: Day of month when discount payment is due (integer or 0)\n- Net_Beginning_Month_C_N: Whether net payment is from Current or Next month (C, N) - write C if not mentioned\n- Discount_Beginning_Month_C_N: Whether discount is from Current or Next month (C, N) - write C if not mentioned\n- Discount_%: Discount percentage as decimal (float or 0)\n\nReturn ONLY the JSON object, nothing else.\n\nExamples:\n* \"30 days Due net\" -> {{'Days_to_Pay_Net': 30, 'Days_to_Discount': 0, 'Day_of_Month_to_Net': 0, 'Day_of_Month_to_Discount': 0, 'Net_Beginning_Month_C_N': 'C', 'Discount_Beginning_Month_C_N': 'C', 'Discount_%': 0}}\n* \"within 60 days 3 % cash discount within 61 days Due net\" -> {{'Days_to_Pay_Net': 60, 'Days_to_Discount': 61, 'Day_of_Month_to_Net': 0, 'Day_of_Month_to_Discount': 0, 'Net_Beginning_Month_C_N': 'C', 'Discount_Beginning_Month_C_N': 'C', 'Discount_%': 0.03}}\n* \"1% 10, NET 31\" -> {{'Days_to_Pay_Net': 31, 'Days_to_Discount': 10, 'Day_of_Month_to_Net': 0, 'Day_of_Month_to_Discount': 0, 'Net_Beginning_Month_C_N': 'C', 'Discount_Beginning_Month_C_N': 'C', 'Discount_%': 0.01}}\n* \"4% 10th day net 30\" -> {{'Days_to_Pay_Net': 30, 'Days_to_Discount': 0, 'Day_of_Month_to_Net': 0, 'Day_of_Month_to_Discount': 10, 'Net_Beginning_Month_C_N': \u2018C\u2019, 'Discount_Beginning_Month_C_N': \u2018C\u2019, 'Discount_%': 0.04}}\n* \u201c1-30 Net 60\u201d -> {{'Days_to_Pay_Net': 60, 'Days_to_Discount': 30, 'Day_of_Month_to_Net': 0, 'Day_of_Month_to_Discount': 0, 'Net_Beginning_Month_C_N': \u2018C\u2019, 'Discount_Beginning_Month_C_N': \u2018C\u2019, 'Discount_%': 0.01}}\n* \u201cwithin 30 days 2 % cash discount within 31 days Due net\u201d -> {{'Days_to_Pay_Net': 31, 'Days_to_Discount': 30, 'Day_of_Month_to_Net': 0, 'Day_of_Month_to_Discount': 0, 'Net_Beginning_Month_C_N': \u2018C\u2019, 'Discount_Beginning_Month_C_N': \u2018C\u2019, 'Discount_%': 0.02}}\n\"\"\"\n        )\n\n    def send_request(self, base_url: str, headers: dict, retries: int = 5) -> dict:\n        \"\"\"\n        Sends a request to the LLM endpoint with retry logic.\n\n        :param base_url: Base URL of the API.\n        :param headers: Headers for the API request.\n        :param retries: Number of retry attempts.\n        :return: JSON response from the LLM.\n        :raises RuntimeError: If all retry attempts fail.\n        \"\"\"\n        endpoint = f\"{base_url}/api/v1/internal/llmchat\"\n        body = {\n            \"messages\": [{\"role\": \"user\", \"content\": self.prompt}],\n            \"temperature\": self.temperature,\n        }\n        for attempt in range(retries):\n            try:\n                response = requests.post(endpoint, headers=headers, json=body)\n                response.raise_for_status()\n                return response.json()\n            except RequestException as e:\n                self.t.show_error(f\"Request exception encountered: {e}\")\n                if attempt < retries - 1:\n                    time.sleep(2**attempt)\n        raise RuntimeError(\"Exceeded maximum retry attempts for the LLM request.\")\n\n\ndef format_validation_errors(errors: list[dict]) -> str:\n    \"\"\"\n    Formats validation errors into a readable string.\n\n    :param errors: List of validation error dictionaries.\n    :return: Formatted error string.\n    \"\"\"\n    messages = []\n    for err in errors:\n        field_name = \".\".join(str(loc) for loc in err.get(\"loc\", []))\n        error_msg = err.get(\"msg\", \"Invalid value\")\n        messages.append(f\"{field_name}: {error_msg}\")\n    return \"Validation Error(s):\\n\" + \"\\n\".join(messages)\n\n\ndef check_for_updates(\n    t: TxScript, input_map: dict[str, str], updated_datapoints: list[str]\n) -> bool:\n    \"\"\"\n    Checks if any of the input fields have been updated.\n\n    :param t: TxScript object.\n    :param input_map: Mapping of input fields to check.\n    :param updated_datapoints: List of updated datapoints.\n    :return: True if any input fields are updated, False otherwise.\n    \"\"\"\n    for field in input_map.values():\n        field_id = getattr(t.field, field).attr.id\n        if field_id in updated_datapoints:\n            return True\n    return False\n\n\ndef check_condition(t: TxScript, condition: str) -> bool:\n    \"\"\"\n    Evaluates a condition string.\n\n    :param t: TxScript object.\n    :param condition: Condition string to evaluate.\n    :return: True if the condition is met, False otherwise.\n    :raises ValueError: If the condition contains an invalid field.\n    \"\"\"\n    if not condition:\n        return True\n\n    try:\n        if \"==\" in condition:\n            field, value_expected = map(str.strip, condition.split(\"==\"))\n            value_expected = value_expected.strip(\"'\\\"\")\n            actual_value = getattr(t.field, field.strip(\"{}\")).value\n            return str(actual_value) == str(value_expected)\n        elif \"!=\" in condition:\n            field, value_expected = map(str.strip, condition.split(\"!=\"))\n            value_expected = value_expected.strip(\"'\\\"\")\n            actual_value = getattr(t.field, field.strip(\"{}\")).value\n            return str(actual_value) != str(value_expected)\n        else:\n            field = condition.strip(\"{}\")\n            val = getattr(t.field, field).value\n            return not is_empty(val)\n    except AttributeError:\n        raise ValueError(f\"Invalid field in condition: {condition}\")",
    "third_party_library_pack": "default",
    "memory_size_mb": 256
  },
  "test": {},
  "sideload": [
    "schemas"
  ],
  "settings_schema": null,
  "secrets_schema": {
    "type": "object",
    "additionalProperties": {
      "type": "string"
    }
  },
  "token_owner": "https://us.api.rossum.ai/v1/users/383208",
  "extension_source": "custom",
  "guide": null,
  "read_more_url": null,
  "extension_image_url": null,
  "token_lifetime_s": null,
  "hook_template": null,
  "created_by": null,
  "created_at": null,
  "modified_by": "https://us.api.rossum.ai/v1/users/354857",
  "modified_at": "2025-03-27T13:16:18.643553Z"
}