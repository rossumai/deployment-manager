Here's a documentation for duplicates detection extension in Rossum a platform for intelligent document processing with AI.

You have the following knowledge of duplicate handling and its possible configurations:
The Duplicate Handling Extension in Rossum is designed to identify and manage duplicate documents efficiently. Here's a comprehensive summary of its configuration options:
Trigger Events:
Define when the configuration should be activated. Common events include annotation_status and annotation_content.
Trigger Actions:
Specify actions that trigger the configuration, such as changed, initialize, updated, started, confirm, export, and user_update.
Statuses:
A list of annotation status couples (e.g., importing.to_review) that define when the processing logic should be applied.
Logic:
The core of the duplicate handling extension, defining rules, scope, matching flow, timestamp, and actions.
Rules:
Criteria for detecting duplicates, based on:
Field: Extracted field values (e.g., document_id).
Filename: The filename of the document.
Relation: File hash.
Each rule has an id and an attribute specifying the type of detection.
Matching Flow:
Defines how rules are combined using logical operations.
Example: ["1and2", "3"] combines rule 1 and 2 with an "and" operation, and rule 3 separately with an "or" operation.
Scope:
Determines where to look for duplicates: queue, workspace, or organization.
Can specify IDs and statuses of annotations to consider.
Timestamp:
Sets a time range for duplicate detection, using action (e.g., arrived_at_after) and timespan in days.
Actions:
Operations executed when duplicates are detected:
Fill Field: Populate a field with a specific value.
Forward Annotation: Move the annotation to a different queue/status.
Mark Duplicate: Flag the document as a duplicate.
Show Message: Display a custom message on the document.
Stop Automation: Halt further automated processing.
Apply Label: Add a label to the document.
This is the actual configuration:

JSON:
{attributes}

Related extensions:
{run_after}

return a structured markdown table with the following aspects (omit any urls from output, do not return anything else besides this table):
- header row print in h3 markdown: "Extension: [Extension Name] (extension_id)"
- after header row, follow 2 column layout with (column title / description)
- "Summary" = in the "description column" provide executive a brief max 2 sentence description of the actual matching logic including fields which are used for the check
- "Fields Used" = in the "description column" provide which fields (schema_ids) are used in the configuration.
- "Logic" = in the "description column" write what does the extension do (bullet point, hint: Use description if available. You can also infer it based on the extension’s ‘code’ attribute if available.)
- "Events" = in the "description column" write on which events is the hook triggered
- "Related Extensions" = in the "description column" list hooks that are listed in ‘run_after’ attribute. Look at the IDs of the related extensions section to know which is which and list their name as well as ID.
- "Active Queues" = in the "description column", print only the human readable name (queue_id) where this extension applies, omit any URLs
