Generate markdown documentation for this Rossum document splitting extension (hook).

JSON:
{attributes}


Here is what you need to know (about Rossum configurations in general):
- Rossum extension is a separate piece of functionality that runs on certain events.

Background Information (for context):
Rossum allows users to upload multi-page PDFs that may contain multiple business documents in a single file (e.g. a batch scan of 10 invoices or delivery notes). The Document Splitting extension is designed to automatically divide these into individual documents before data extraction takes place. Each resulting document is processed independently through Rossum’s pipeline.
This extension is event-driven and is triggered after the document is uploaded, but before any data capture or annotation is performed.
About the Configuration
The configuration is a JSON object that defines how the splitting should work. It may include fields such as:
split_type: Strategy used for splitting. Typical values include:


"blank_page": Splits the document wherever a blank page is detected.


"keyword": Splits when a specific word or phrase appears.


"barcode": Splits based on detection of a barcode.


"page_ranges": Splits based on explicitly defined page groups.


keyword: The text that triggers a new document split (used only with split_type: "keyword").


barcode_type: Optional filter for the type of barcode (e.g. QR, EAN).


barcode_content: Defines the expected format or pattern of barcode content.


min_pages: The minimum number of pages required to allow splitting.


combine_single_page_documents: Boolean flag to merge consecutive single-page documents into one.


confidence_threshold: OCR confidence threshold for text-based splitting logic.


Additional optional fields may control fallback behavior, debugging output, or OCR settings.


This configuration controls the logic used by the extension to detect document boundaries and how those boundaries are interpreted.

return a structured markdown table with the following aspects (omit any urls from output, do not return anything else besides this table):
- header row print in h3 markdown: "Extension: [Extension Name] (extension_id)"
- after header row, follow 2 column layout with (column title / description)
- "Summary" = in the "description column" provide executive a brief max 2 sentence description of the actual matching logic including fields which are used for the check
- "Fields Used" = in the "description column" provide which fields (schema_ids) are used in the configuration. Return field names delimited in `` separated by comma.
- "Logic" = in the "description column" write what does the extension do (bullet point, hint: Use description if available. You can also infer it based on the extension’s ‘code’ attribute if available. Return bullet points list printed in <ul><li></li></ul>.
- "Events" = in the "description column" write on which events is the hook triggered. Return field names delimited in `` separated by comma.
- "Related Extensions" = in the "description column" list hooks that are listed in ‘run_after’ attribute. Look at the IDs of the related extensions section to know which is which and list their name as well as ID. Return bullet points list printed in <ul><li></li></ul>, sorted A-Z, with extension names delimited in ``.
- "Active Queues" = in the "description column", return Return bullet points list printed in <ul><li></li></ul> of only the human readable name (queue_id) where this extension applies, omit any URLs, sort queue names A-Z